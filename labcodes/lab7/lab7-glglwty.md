#lab7实验报告
2012011282 计22 王天一
##练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）
###1.1 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
内核级信号量的实现方式是设计为设定一个等待队列，进行操作时禁止中断并且操作这个等待队列来实现等待和唤醒。  
`static __noinline void __up(semaphore_t *sem, uint32_t wait_state)`的功能是将信号量+1。  
流流程为  
```
禁止中断
如果没人在等待这个信号量，则将其值＋1
否则唤醒等待队列中的第一个进程
开启中断
```
`static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state)`的功能是等待一个信号量。  
流流程为  
```
禁止中断
如果信号量的值大于0，则直接将信号量－1，开启中断返回
否则开启中断，将自己加入等待队列并睡眠
```
###1.2 请在实验报告中给出给户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
在用户头文件提供`sem_handle`结构体，实际上就是一个标号，内核内建立sem表，负责存放用户程序的信号量，提供`sys_initsem`，`sys_waitsem`系统调用和`sys_signalsem`系统调用。系统调用的处理与内核中相同即可。  
主要区别就是不能把`sem`结构体暴露出来。  
##练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）
###2.1 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。  
我们将等待条件的人称为B，将触发条件的人称为A。  
建立一个monitor，monitor中设一个条件锁`mutex`，这个锁是为了让条件不能同时被两人修改的。另设一个next信号量，这个信号量是为了让A在signal之后等待B退出临界区的。再设一个`cvp->sem`信号量，这个信号量是为了让B等待A触发信号的。  
执行流程为B获得`mutex`，然后执行wait，在wait中B释放`mutex`等待`cvp->sem`，A触发cvp->sem，等待next，B释放next退出临界区，A继续执行退出临界区。
###2.2 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
看上去用户可以自己拿`sem`去实现`condvar`，没有什么阻碍，`condvar`的实现既不用特权命令也不用开关中断，至少单核条件下是这样，所以这个没太大必要。  
如果要实现的话给用户提供`condvar_handle`，内核内建立`condvar_pool`,然后提供`init`,`wait`,`signal`三个系统调用即可。主要区别还是不暴露内部实现。  
